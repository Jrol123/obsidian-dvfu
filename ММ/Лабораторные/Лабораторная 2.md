**Поповкин Артемий Андреевич**
**Б9122-02.03.01 СЦТ**
# Постановка задачи
Требуется для модели **Лотки-Вольтерры** определить численность популяции в будущем на основе начальной численности жертв и хищников, темпов роста обоих популяций и коэффициентов, отражающих взаимодействия между ними.

# Описание модели
## Описание
Модель Лотки-Вольтерры описывает динамику взаимодействия двух биологических видов с отношениями "Хищиник-Жертва" или "Паразит-Хозяин".

### Обозначения
- $t$ — время (размерность: годы)
#### Входные данные
- $H_{0}$ — начальная численность популяции хищников (размерность: тысячи)
- $P_{0}$ — начальная численность популяции жертв (размерность: тысячи)
#### Фазовые переменные
- $H\left( t \right)$ — численность популяции хищников в момент времени .
- $P\left( t \right)$ — численность популяции жертв в момент времени $t$.
#### Параметры
- $\alpha$ — коэффициент рождаемости жертв.
- $\beta$ — коэффициент убийства жертв хищниками.
- $\gamma$ — коэффициент смертности хищников.
- $\delta$ — коэффициент рождаемости хищников.

### Уравнение
$$
\begin{cases}
\dot{P} = \left( \alpha - \beta H \right) P \\
\dot{H} = \left( -\gamma + \delta P \right) H
\end{cases}
$$
Решением уравнения будет называть функцию, удовлетворяющую следующей задаче Коши:
$$
\begin{cases}
\dot{P} = \left( \alpha - \beta H \right) P \\
\dot{H} = \left( -\gamma + \delta P \right) H \\
P\left( 0 \right) = P_{0} \quad H\left( 0 \right) = H_{0} 
\end{cases}
$$

# Аналитическое исследование системы
## Условие устойчивости
Для начала найдём равновесия модели:
$$
\cases{
(\alpha - \beta H) P = 0 \\
(-\gamma + \delta P) H = 0
}
$$
Решив систему, получаем следующие два равновесия:
**Тривиальное**
$$
P_{t} = H_{t} = 0
$$
**Нетривиальное**
$$
\cases{
\alpha - \beta H = 0 \\
-\gamma + \delta P = 0
} \implies \cases{
H_{nt}= \dfrac{\alpha}{\beta} \\
P_{nt} = \dfrac{\gamma}{\delta}
}
$$

Теперь исследуем полученные равновесные точки на устойчивость.
Для этого найдем собственные значения матрицы Якоби системы в данных точках. 
$$
J - \lambda E =
\begin{pmatrix}
\alpha - \beta H - \lambda && -\beta P \\
\delta H && -\gamma + \delta P - \lambda
\end{pmatrix}
$$
**Тривиальное равновесие**
$$
\det(J - \lambda E) \underset{ P = P_{t},\ H = H_{t}}{ = }  - (\alpha - \lambda) (\gamma + \lambda) = 0 \implies
\begin{cases}
\lambda_{1} = \alpha \\
\lambda_{2} = -\gamma
\end{cases}
$$
Так как $\operatorname{Im} \lambda_{1, 2} = 0,\ \operatorname{Re} \lambda_{1} > 0,\ \operatorname{Im} \lambda_{2} < 0$, можем заключить, что тривиальное равновесие неустойчиво и является седловой точкой. 

**Нетривиальное равновесие**
$$
\det(J-\lambda E) |_{x=x_{nt}, y=y_{nt}} = \lambda^{2} + \alpha \gamma = 0 \implies
\lambda_{1, 2} = \pm \sqrt{\alpha \gamma} ~i
$$
Исходя из того, что $\operatorname{Re}\lambda_{1, 2} = 0,\ \operatorname{Im} \lambda_{1} > 0,\ \operatorname{Im} \lambda_{2} < 0$, получаем, что нетривиальное равновесие является центром (устойчиво).


# Численные эксперименты
Был выбран временной диапазон с 1847 по 1903 гг.
Популяция зайцев и рысей указана в тысячах.
![[Pasted image 20251106003443.png]]
## Основные расчёты

# Использованные данные
https://www.kaggle.com/datasets/mehedihasan9021/population-dataset
# Листинг кода
```python
# Imports
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import minimize
from scipy.integrate import solve_ivp
# Funcs
## Math
def objective(
    params: tuple[float, float, float, float], data: tuple[float, float, float], y0
):
    H_data, L_data, t_data = data
    y_pred = model(params, t_data, y0)
    error_H = np.mean((y_pred[0] - H_data) ** 2)
    error_L = np.mean((y_pred[1] - L_data) ** 2)
    return error_H + error_L


def model(params: tuple[float, float, float, float], t, y0):
    solution = solve_ivp(
        lotka_volterra, [t[0], t[-1]], y0, args=(params), t_eval=t, method="RK45"
    )
    return solution.y


def lotka_volterra(t, y, alpha, beta, delta, gamma):
    # alpha, beta, delta, gamma = params
    H, L = y
    dHdt = alpha * H - beta * H * L
    dLdt = delta * H * L - gamma * L
    return [dHdt, dLdt]


def runge_kutta_4th_order(
    f, y0, t_span, n_steps: int, params: tuple[float, float, float, float]
):
    alpha, beta, delta, gamma = params
    t_start, t_end = t_span
    t = np.linspace(t_start, t_end, n_steps)
    h = (t_end - t_start) / (n_steps - 1)
    y = np.zeros((len(y0), n_steps))
    y[:, 0] = y0
    for i in range(n_steps - 1):
        k1 = h * np.array(f(t[i], y[:, i], alpha, beta, delta, gamma))
        k2 = h * np.array(f(t[i] + h / 2, y[:, i] + k1 / 2, alpha, beta, delta, gamma))
        k3 = h * np.array(f(t[i] + h / 2, y[:, i] + k2 / 2, alpha, beta, delta, gamma))
        k4 = h * np.array(f(t[i] + h, y[:, i] + k3, alpha, beta, delta, gamma))
        y[:, i + 1] = y[:, i] + (k1 + 2 * k2 + 2 * k3 + k4) / 6
    return t, y
# Data
df = pd.read_csv("../data/hudson-bay-lynx-hare.csv")
df

P_col_name = " Hare"
H_col_name = " Lynx"
t_col_name = "Year"

t_data = df[t_col_name].values
H_data = df[P_col_name].values
L_data = df[H_col_name].values
data = (H_data, L_data, t_data)

y0 = [H_data[0], L_data[0]]
# Calculation
## Params calculation
initial_guess = [1.0, 0.1, 0.01, 0.375]
bounds = [(0.001, 10), (0.001, 1), (0.001, 1), (0.001, 1)]

result = minimize(objective, initial_guess, args=(data, y0), bounds=bounds, method="L-BFGS-B")
params = result.x
alpha, beta, delta, gamma = params
alpha, beta, delta, gamma
## Calculation on hystorical data
H0 = df[P_col_name].iloc[0]
L0 = df[H_col_name].iloc[0]
t_span = (df[t_col_name].iloc[0], df[t_col_name].iloc[-1])
n_steps = 1000
y0 = [H0, L0]
t_rk, y_rk = runge_kutta_4th_order(lotka_volterra, y0, t_span, n_steps, params)
# Visualisation
# Визуализация результатов
plt.figure(figsize=(15, 10))
plt.plot(
    df[t_col_name],
    df[P_col_name],
    "dodgerblue",
    label="Реальные данные: зайцы",
    zorder=2,
)
plt.plot(
    df[t_col_name], df[H_col_name], "limegreen", label="Реальные данные: рыси", zorder=2
)
plt.plot(t_rk, y_rk[0], "royalblue", linestyle="--", label="Модель: зайцы", zorder=1)
plt.plot(t_rk, y_rk[1], "forestgreen", linestyle="--", label="Модель: рыси", zorder=1)
plt.legend()
plt.xlabel("Год")
plt.ylabel("Численность")
plt.plot()

# Фазовый портрет
plt.figure(figsize=(15, 10))
plt.plot(df[P_col_name], df[H_col_name], "darkred", label="Реальные данные", zorder=2)
plt.plot(y_rk[0], y_rk[1], "red", linestyle="--", label="Модельные данные", zorder=1)
plt.legend()
plt.xlabel("Численность зайцев")
plt.ylabel("Численность рысей")
plt.plot()
H0_forecast = y_rk[0][-1]
L0_forecast = y_rk[1][-1]
last_year = df[t_col_name].iloc[-1]
# Период прогноза
forecast_years = 10
t_span_forecast = (last_year, last_year + forecast_years)
n_steps_forecast = 1000
# Прогноз с использованием последних известных значений
t_forecast, y_forecast = runge_kutta_4th_order(
    lotka_volterra,
    [H0_forecast, L0_forecast],
    t_span_forecast,
    n_steps_forecast,
    params,
)
# Визуализация прогноза
plt.figure(figsize=(15, 10))
# Исторические данные
plt.plot(
    df[t_col_name],
    df[P_col_name],
    "dodgerblue",
    label="Исторические данные: зайцы",
    linewidth=2,
)
plt.plot(
    df[t_col_name],
    df[H_col_name],
    "limegreen",
    label="Исторические данные: рыси",
    linewidth=2,
)
# Модель на историческом периоде
plt.plot(t_rk, y_rk[0], "blue", linestyle="--", label="Модель: зайцы", alpha=0.7)
plt.plot(t_rk, y_rk[1], "green", linestyle="--", label="Модель: рыси", alpha=0.7)
# Прогноз
plt.plot(
    t_forecast, y_forecast[0], "red", linestyle="-", label="Прогноз: зайцы", linewidth=2
)
plt.plot(
    t_forecast,
    y_forecast[1],
    "orange",
    linestyle="-",
    label="Прогноз: рыси",
    linewidth=2,
)
# Вертикальная линия разделяющая историю и прогноз
plt.axvline(
    x=last_year, color="black", linestyle=":", alpha=0.7, label="Начало прогноза"
)
plt.legend()
plt.xlabel("Год")
plt.ylabel("Численность")
plt.show()
```